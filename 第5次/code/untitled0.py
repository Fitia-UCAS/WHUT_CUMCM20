# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l1aQ3-BhBtZA9jlKpqy1K5GYrnIznm6r
"""

import pandas as pd
import numpy as np
import random



data = pd.read_excel('/content/drive/My Drive/competitions/CMCM/demo5/data.xls')
data.head()

#coding:utf-8
#Importing required modules
import math
import random
import numpy as np
import pandas as pd
from tqdm.notebook import tqdm
import matplotlib.pyplot as plt
plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签
plt.rcParams['axes.unicode_minus']=True #用来正常显示负号

def missing_data(data):
    total = data.isnull().sum()
    percent = (data.isnull().sum()/data.isnull().count()*100)
    tt = pd.concat([total, percent], axis=1, keys=['Total', 'Percent'])
    types = []
    for col in data.columns:
        dtype = str(data[col].dtype)
        types.append(dtype)
    tt['Types'] = types
    return(np.transpose(tt))


def unique_values(data):
    total = data.count()
    tt = pd.DataFrame(total)
    tt.columns = ['Total']
    uniques = []
    for col in data.columns:
        unique = data[col].nunique()
        uniques.append(unique)
    tt['Uniques'] = uniques
    return(np.transpose(tt))


def most_frequent_values(data):
    total = data.count()
    tt = pd.DataFrame(total)
    tt.columns = ['Total']
    items = []
    vals = []
    for col in data.columns:
        itm = data[col].value_counts().index[0]
        val = data[col].value_counts().values[0]
        items.append(itm)
        vals.append(val)
    tt['Most frequent item'] = items
    tt['Frequence'] = vals
    tt['Percent from total'] = np.round(vals / total * 100, 3)
    return(np.transpose(tt))


def plot_count(feature, title, df, size=1, num=20):
    f, ax = plt.subplots(1,1, figsize=(4*size,4))
    total = float(len(df))
    g = sns.countplot(df[feature], order = df[feature].value_counts().index[:num], palette='Set3')
    g.set_title("Number and percentage of {}".format(title), fontproperties=font)
    if(size > 2):
        plt.xticks(rotation=90, size=8)
    for p in ax.patches:
        height = p.get_height()
        ax.text(p.get_x()+p.get_width()/2.,
                height + 3,
                '{:1.2f}%'.format(100*height/total),
                ha="center", fontproperties=font) 
    plt.show()

unique_values(data)

dingdan = pd.read_excel('/content/drive/My Drive/competitions/CMCM/demo5/data_un.xlsx')
del dingdan['Unnamed: 0']
del dingdan['虚拟板坯号']
del dingdan['钢卷ID号']

dingdan.head(5)

class Loader(object):
  def __init__(self, id, num, water_w, board_w, W, D, H, is_Q, is_Tang, gangzhong):
    self.id = id # 订单号
    self.num = num  # 板胚个数
    self.water_w = water_w # 钢水重量
    self.board_w = board_w # 钢板重量	
    self.W = W  # 宽度
    self.D = D  # 厚度
    self.H = H  # 硬度
    self.is_Tanggun = (is_Q!=2 and is_Tang==1)  # 是否为烫辊材
    self.gangzhong = gangzhong  # 钢种

loaders = []
# num_loader = len(dingdan)
num_loader = 10
for i in range(num_loader):
  l = Loader(dingdan.loc[i]['订单号'], dingdan.loc[i]['数目'], dingdan.loc[i]['钢水重量'],
         dingdan.loc[i]['板坯重量'], dingdan.loc[i]['坯料宽度'], dingdan.loc[i]['坯料厚度'],
         dingdan.loc[i]['板坯硬度'], dingdan.loc[i]['表面质量'], dingdan.loc[i]['是否可为烫辊材'], dingdan.loc[i]['冶炼牌号'])
  loaders.append(l)

! pip install pyecharts



#Function to carry out NSGA-II's fast non dominated sort
#函数执行NSGA-II的快速非支配排序,将所有的个体都分层
'''
1.np=0 sp=infinite
2.对所有个体进行非支配判断，若p支配q，则将q加入到sp中，并将q的层级提升一级。
  若q支配p，将p加入sq中，并将p的层级提升一级。
3.对种群当前分层序号k进行初始化，令k=1
4.找出种群中np=0的个体，将其从种群中移除，将其加入到分层集合fk中，该集合就是层级为0个体的集合。
5.判断fk是否为空，若不为空，将fk中所有的个体sp中对应的个体层级减去1，且k=k+1,跳到2;
  若为空，则表明得到了所有非支配集合，程序结束
'''
"""基于序列和拥挤距离,这里找到任意两个个体p,q"""
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def fast_non_dominated_sort(values1, values2, values3):
    S=[[] for i in range(0,len(values1))]
    # 种群中所有个体的sp进行初始化 这里的len(value1)=pop_size
    front = [[]]
    # 分层集合,二维列表中包含第n个层中,有那些个体
    n=[0 for i in range(0,len(values1))]
    rank = [0 for i in range(0, len(values1))]
    # 评级
 
    for p in range(0,len(values1)):
        S[p]=[]
        n[p]=0
        # 寻找第p个个体和其他个体的支配关系
        # 将第p个个体的sp和np初始化
        for q in range(0, len(values1)):
            #step2:p > q 即如果p支配q,则
            if ((values1[p]>values1[q] and values2[p]>values2[q] and values3[p]>values3[q])   
              or (values1[p]>=values1[q] and values2[p]>values2[q] and values3[p]>=values3[q])
              or (values1[p]>values1[q] and values2[p]>=values2[q] and values3[p]>=values3[q])
              or (values1[p]>=values1[q] and values2[p]>=values2[q] and values3[p]>values3[q])):
            #支配判定条件:当且仅当,对于任取i属于{1,2},都有fi(p)>fi(q),符合支配.
            #或者当且仅当对于任意i属于{1,2},有fi(p)>=fi(q),且至少存在一个j使得fj(p)>fj(q)符合弱支配
                if q not in S[p]:
                    # 同时如果q不属于sp将其添加到sp中
                    S[p].append(q)
            # 如果q支配p
            elif ((values1[q]>values1[p] and values2[q]>values2[p] and values3[q]>values3[p])
             or (values1[q]>=values1[p] and values2[q]>values2[p] and values3[q]>=values3[p]) 
             or (values1[q]>values1[p] and values2[q]>=values2[p] and values3[q]>=values3[p])
             or (values1[q]>=values1[p] and values2[q]>=values2[p] and values3[q]>values3[p])):
                # 则将np+1
                n[p] = n[p] + 1
        if n[p]==0:
            # 找出种群中np=0的个体
            rank[p] = 0
            # 将其从pt中移去
            if p not in front[0]:
                # 如果p不在第0层中
                # 将其追加到第0层中
                front[0].append(p)
    i = 0
    while(front[i] != []):
        # 如果分层集合为不为空，
        Q=[]
        for p in front[i]:
            for q in S[p]:
                n[q] =n[q] - 1
                # 则将fk中所有给对应的个体np-1
                if(n[q]==0):
                    # 如果nq==0
                    rank[q]=i+1
                    if q not in Q:
                        Q.append(q)
        i = i+1
        # 并且k+1
        front.append(Q)
    del front[len(front)-1]
    return front
    # 返回将所有个体分层后的结果


#Function to find index of list
#查找列表指定元素的索引
def index_of(a,list):
    for i in range(0,len(list)):
        if list[i] == a:
            return i
    return -1


#Function to sort by values
# 函数根据指定的值列表排序
'''list1=[1,2,3,4,5,6,7,8,9]
   value=[1,5,6,7]
   sort_list=[1,5,6,7]
'''
def sort_by_values(list1, values):
    sorted_list = []
    while(len(sorted_list)!=len(list1)):
        # 当结果长度不等于初始长度时，继续循环
        if values.index(min(values)) in list1:
            # 标定值中最小值在目标列表中时
            sorted_list.append(values.index(min(values)))
        #     将标定值的最小值的索引追加到结果列表后面
        values[values.index(min(values))] = math.inf
    #      将标定值的最小值置为无穷小,即删除原来的最小值,移向下一个
    #     infinited
    return sorted_list


#Function to calculate crowding distance
#计算拥挤距离的函数
'''
1.I[1]=I[l]=inf，I[i]=0 将边界的两个个体拥挤度设为无穷。
2.I=sort(I,m)，基于目标函数m对种群排序
3.I[i]=I[i]+(Im[i+1]-Im[i-1])/(fmax-fmin)
'''
def crowding_distance(values1, values2, values3, front):
    distance = [0 for i in range(0,len(front))]
    # 初始化个体间的拥挤距离
    sorted1 = sort_by_values(front, values1[:])
    sorted2 = sort_by_values(front, values2[:])
    sorted3 = sort_by_values(front, values3[:])

    # 基于目标函数1和目标函数2对已经划分好层级的种群排序
    distance[0] = 4444444444444444
    distance[len(front) - 1] = 4444444444444444
    for k in range(1,len(front)-1):
        distance[k] = distance[k]+ (values1[sorted1[k+1]] - values1[sorted1[k-1]])/(max(values1)-min(values1))
    for k in range(1,len(front)-1):
        distance[k] = distance[k]+ (values2[sorted2[k+1]] - values2[sorted2[k-1]])/(max(values2)-min(values2))
    for k in range(1,len(front)-1):
        distance[k] = distance[k]+ (values3[sorted3[k+1]] - values3[sorted3[k-1]])/(max(values3)-min(values3))
    return distance
    # 返回拥挤距离



class NSGA(object):
  def __init__(self, loaders, partition_num=None, max_num=20, pop_size=10, c_rate=0.5, m_rate=0.8):
    self.partition_num = partition_num  #隔板数
    self.max_num = max_num      #迭代次数
    self.loaders = loaders      # 订单们
    self.pop_size = pop_size      # 种群数目
    self.c_rate = c_rate      # 交换率
    self.m_rate = m_rate      # 突变率
    pass
  
  def encode(self):  # 初始化编码, 问题的解
    gens = []
    if self.partition_num!=None:  
      for x in range(self.partition_num): # 隔板的每一个基因
        gen = []
        for l in self.loaders:
          gen.append(random.randint(0,l.num-1)) # 初始化每一个隔板的位置
        gens.append(gen)
    gens = np.sort(gens, axis =  0)   # 按列排叙。列为单个订单的插板
    return np.array(gens)

  def creat_pop(self, size):
    pop = []
    for i in range(size):
      pop.append(self.encode())  # 加入种群
    return pop
  
  def cross(self, parent1, parent2):
    """交叉p1,p2的部分基因片段"""
    # if np.random.rand() > self.c_rate:
    #     return parent1
    newGene = np.zeros((parent1.shape[0], parent1.shape[1]), dtype = np.int) 
    for i in range(parent1.shape[1]):     # 交叉，这里待优化
      for j in range(parent1.shape[0]):
        # if parent2[j][i]>=parent1[j][i]:
        #   newGene[j][i] = random.randint(parent1[j][i], parent2[j][i])  # 取两个父代中间的随机数
        # else:
        #   newGene[j][i] = random.randint(parent2[j][i], parent1[j][i])  # 取两个父代中间的随机数

        if np.random.rand() > self.c_rate:
          newGene[j][i] = parent1[j][i] # 取两个父代中间的随机数
        else:
          newGene[j][i] = parent2[j][i]  # 取两个父代中间的随机数
    newGene = np.sort(newGene, axis =  0)   # 按列排叙。列为单个订单的插板
    return newGene
  
  def mutate(self, gene):
    """突变"""
    if np.random.rand() > self.m_rate:
        return gene
    newGene = gene.copy()
    lingyu = 10   # 领域，在小范围变化
    for i in range(gene.shape[1]):     # 交叉，这里待优化
      for j in range(gene.shape[0]):
        if np.random.rand()>0.8:
          newGene[j][i] = newGene[j][i] + random.randint(0,lingyu) if newGene[j][i]+lingyu<self.loaders[i].num else newGene[j][i]
        elif np.random.rand()<0.2:
          newGene[j][i] = newGene[j][i] - random.randint(0,lingyu) if newGene[j][i]-lingyu>0 else newGene[j][i]
        # if np.random.rand()>0.8:
        #   newGene[j][i] = random.randint(0,self.loaders[i].num-1)
    return newGene
  
  def get_fitness(self, pop):
    d = [] # 适应度记录数组
    for i in range(pop.shape[0]):
        gens = pop[i]  # 取其中一条基因（编码解，个体）
        f1,f2,f3 = self.get_fun1(gens), self.get_fun2(gens), self.get_fun3(gens)  # 计算此基因优劣（距离长短）
        d.append((f1,f2,f3))
    return d

  def get_fun1(self, gens):
    V1_max = 200  # 容积
    f1 = 0 ####  ？？？？？
    for i in range(self.partition_num):
      if i==0:
        taocan = gens[i]
      elif i==self.partition_num-1:
        taocan1 = np.array([x.num for x in loaders])
        taocan2 = gens[i]
        taocan = taocan1-taocan2
      else:
        taocan1 = gens[i]
        taocan2 = gens[i-1]
        taocan = taocan1-taocan2
      sum_V1 = 0
      for indx, loader in enumerate(loaders):
        sum_V1 = sum_V1 + loader.water_w * taocan[indx]
      f1 = f1 + V1_max*(int(sum_V1/V1_max)+1)-sum_V1
    return -f1
  
  def get_fun2(self, gens):
    V2_max = 2550  # 容积
    f2 = 0 ####  ？？？？？
    for i in range(self.partition_num):
      if i==0:
        taocan = gens[i]
      elif i==self.partition_num-1:
        taocan1 = np.array([x.num for x in loaders])
        taocan2 = gens[i]
        taocan = taocan1-taocan2
      else:
        taocan1 = gens[i]
        taocan2 = gens[i-1]
        taocan = taocan1-taocan2
      sum_V2 = 0
      for indx, loader in enumerate(loaders):
        sum_V2 = sum_V2 + loader.board_w * taocan[indx]
      f2 = f2 + V2_max*(int(sum_V2/V2_max)+1)-sum_V2
    return -f2

  def get_fun3(self, gens):
    V3_max = 60000 # 容积
    V3_min = 40000
    C = 500
    f3 = 0  ####  ？？？？？
    for i in range(self.partition_num):
      if i==0:
        taocan = gens[i]
      elif i==self.partition_num-1:
        taocan1 = np.array([x.num for x in loaders])
        taocan2 = gens[i]
        taocan = taocan1-taocan2
      else:
        taocan1 = gens[i]
        taocan2 = gens[i-1]
        taocan = taocan1-taocan2
      sum_V3 = 0
      for indx, loader in enumerate(loaders):
        sum_V3=sum_V3+loader.D * taocan[indx]
      # print(sum_V3, V3_max-sum_V3)
      f3 = f3 + abs(V3_max-sum_V3) #+ abs(min(V3_max-sum_V3,0)*C) + abs(min(sum_V3-V3_min,0)*C)     # 负的罚函数
      # f3 = f3 + V3_max-sum_V3 + abs(min(V3_max-sum_V3,0)*C) # + abs(min(sum_V3-V3_min,0)*C)     # 负的罚函数
    return -f3

  def evolution(self):
    self.pop = self.creat_pop(self.pop_size)
    for num in tqdm(range(self.max_num)):
      function1_values = [self.get_fun1(x)for x in self.pop]
      function2_values = [self.get_fun2(x)for x in self.pop]
      function3_values = [self.get_fun3(x)for x in self.pop]

      self.F = 0.5+np.random.rand()

      # 生成两个函数值列表，构成一个种群
      non_dominated_sorted_solution = fast_non_dominated_sort(function1_values[:],function2_values[:],function3_values[:])
      # 种群之间进行快速非支配性排序, 得到非支配性排序集合
      # print("The best front for Generation number ",num, " is")
      # for valuez in non_dominated_sorted_solution[0]:
      #     print(self.pop[valuez],end=" ")
      # print("\n")
      crowding_distance_values=[]
      # 计算非支配集合中每个个体的拥挤度
      for i in range(0,len(non_dominated_sorted_solution)):
          crowding_distance_values.append(crowding_distance(function1_values[:],function2_values[:]
                    ,function3_values[:],non_dominated_sorted_solution[i][:]))
      # print(crowding_distance_values)
      # 变异
      for i in range(self.pop_size):
        self.pop[i] = self.mutate(self.pop[i])

      solution2 = self.pop
      #生成了子代
      while(len(solution2)!=2*self.pop_size):
          a1 = random.randint(0,self.pop_size-1)
          b1 = random.randint(0,self.pop_size-1)
          # 选择
          solution2.append(self.cross(self.pop[a1],self.pop[b1]))

      function1_values2 = [self.get_fun1(x)for x in solution2]
      function2_values2 = [self.get_fun2(x)for x in solution2]
      function3_values2 = [self.get_fun3(x)for x in solution2]

      non_dominated_sorted_solution2 = fast_non_dominated_sort(function1_values2[:],function2_values2[:],function3_values2[:])
      # print('************',non_dominated_sorted_solution2)
      # 将两个目标函数得到的两个种群值value,再进行排序 得到2*pop_size解
      crowding_distance_values2=[]
      for i in range(0,len(non_dominated_sorted_solution2)):
          crowding_distance_values2.append(crowding_distance(function1_values2[:],function2_values2[:],function3_values2[:],non_dominated_sorted_solution2[i][:]))
      # 计算子代的个体间的距离值
      new_solution= []
      for i in range(0,len(non_dominated_sorted_solution2)):
          non_dominated_sorted_solution2_1 = [index_of(non_dominated_sorted_solution2[i][j],non_dominated_sorted_solution2[i] ) for j in range(0,len(non_dominated_sorted_solution2[i]))]
          #排序
          front22 = sort_by_values(non_dominated_sorted_solution2_1[:], crowding_distance_values2[i][:])
          front = [non_dominated_sorted_solution2[i][front22[j]] for j in range(0,len(non_dominated_sorted_solution2[i]))]
          front.reverse()
          for value in front:
              new_solution.append(value)
              if(len(new_solution)==self.pop_size):
                  break
          if (len(new_solution) == self.pop_size):
              break
      self.pop = [solution2[i] for i in new_solution]


    function1_values = [self.get_fun1(x)for x in self.pop]
    function2_values = [self.get_fun2(x)for x in self.pop]
    function3_values = [self.get_fun3(x)for x in self.pop]
    non_dominated_sorted_solution = fast_non_dominated_sort(function1_values[:],function2_values[:],function3_values[:])

    best = []
    for valuez in non_dominated_sorted_solution[0]:
        best.append(self.pop[valuez])
    # 帕解
    function1_values = [-self.get_fun1(x)for x in best]
    function2_values = [-self.get_fun2(x)for x in best]
    function3_values = [-self.get_fun3(x)for x in best]

    fig = plt.figure()
    ax1 = plt.axes(projection='3d')
    ax1.scatter3D(function1_values,function2_values,function3_values, cmap='Blues')  #绘制散点图
    plt.show()
    return function1_values, function2_values, function3_values

partition_num_max = int(sum(dingdan.loc[:num_loader]['坯料厚度']*dingdan.loc[:num_loader]['数目'])/40000)
partition_num_min = int(sum(dingdan.loc[:num_loader]['坯料厚度']*dingdan.loc[:num_loader]['数目'])/60000)
partition_num_min,partition_num_max

nsga = NSGA(loaders, partition_num=12, pop_size=100, max_num=500)
x = nsga.encode()
nsga.get_fun1(x),nsga.get_fun2(x),nsga.get_fun3(x)

function1_values, function2_values, function3_values = nsga.evolution()

#归一化
f1 = [(x - min(function1_values))/(max(function1_values)-min(function1_values)) for x in function1_values]
f2 = [(x - min(function2_values))/(max(function2_values)-min(function2_values)) for x in function2_values]
f3 = [(x - min(function3_values))/(max(function3_values)-min(function3_values)) for x in function3_values]
#放缩
# f1 = [x/10 for x in function1_values]
# f2 = [x/100 for x in function2_values]
# f3 = [x/1000 for x in function3_values]
# f1 = function1_values
# f2 = function2_values
# f3 = function3_values

import os,random
from pyecharts import options as opts
from pyecharts.charts import Scatter3D
filename = "scatter-3d.html"
data = []
for i in range(len(function1_values)):
  data.append((f1[i], f2[i], f3[i]))
scatter = (
    Scatter3D()
    .add("",data,
        xaxis3d_opts=opts.Axis3DOpts(
            name="Fun(1)",
            type_="value",
            # textstyle_opts=opts.TextStyleOpts(color="#fff"),
        ),
        yaxis3d_opts=opts.Axis3DOpts(
            name="Fun(2)",
            type_="value",
            # textstyle_opts=opts.TextStyleOpts(color="#fff"),
        ),
        zaxis3d_opts=opts.Axis3DOpts(
            name="Fun(3)",
            type_="value",
            # textstyle_opts=opts.TextStyleOpts(color="#fff"),
        ),
        # grid3d_opts=opts.Grid3DOpts(width=100, height=100, depth=100),
  )
    .set_global_opts(
        title_opts=opts.TitleOpts(title="Best Pareto Scatter"),
    )
    .render(filename)
)
os.system(filename)

len(data)

for i in tqdm(range(100)):
  x1 = nsga.encode()
  print(nsga.get_fun3(x1))

function3_values







